---
sidebar_position: 2
id: Fiber
title: React源码：Fiber结构
---
react15在人的认同阶段的协调【reconcile】过程是不能打断的，那么在进行大量节点更新的时候，就会造成卡顿，因为浏览器所有的时间都用来执行js，而js的执行是单线程的，所以在协调过程中就会卡顿。

react16之后，添加schedule过程，也就是调度过程，给每一个工作单元一定的时间，在这个时间内没有执行完成的，就暂时跳出来。那么异步中断的更新需要一定的数据结构来存储工作单元的信息，这就是Fiber。

Fiber的作用：
1. 作为工作单元，存储了节点信息已经节点的优先级，这些节点通过指针形式构成了Fiber树；
2. 增量渲染更新，通过jsx对象和currentFiber对比，找出差异，并且应用到真实DOM上去
3. 根据节点的优先级暂停、继续、排序优先级：因为Fiber上存有优先级，那么就可以通过不同节点的优先级的对比，来完成任务的暂停、继续、排列优先级，为上层实现批量更新、Suspense提供基础；
4. 保存状态：Fiber上有状态和更新信息，就可以实现函数组件的状态更新，这就是hooks。

Fiber结构：

```javascript
function FiberNode(
  tag: WorkTag,
  pendingProps: mixed, 
  key: null | string, 
  mode: TypeOfMode, 
) {
  // 实例
  this.tag = tag; // 标记不同的组件类型
  this.key = key; // reactElement的key，也就是key属性
  this.elementType = null; // 元素类型，是createElement函数的第一个参数
  this.type = null; // 异步组件resolve返回的内容，是function或者class
  this.stateNode = null; // 真实dom节点

  // Fiber树的结构
  this.return = null; // 指向父节点，处理完该节点后，向上返回
  this.child = null; // 指向child
  this.sibling = null; // 指向兄弟节点
  this.index = 0;

  this.ref = null; // ref属性

  this.pendingProps = pendingProps; // 新变动带来新的props
  this.memoizedProps = null; // 上次渲染后的props
  this.updateQueue = null; // 更新队列存放组件产生的update
  this.memoizedState = null; // 上次渲染的state
  this.dependencies = null; // 

  this.mode = mode; // 

  // Effects
  this.flags = NoFlags;
  this.subtreeFlags = NoFlags;
  this.deletions = null;

  //优先级
  this.lanes = NoLanes;
  this.childLanes = NoLanes;
  // current和workInProgress的指针
  this.alternate = null;

  // 启动分析器时间
  if (enableProfilerTimer) {
    // Note: The following is done to avoid a v8 performance cliff.
    //
    // Initializing the fields below to smis and later updating them with
    // double values will cause Fibers to end up having separate shapes.
    // This behavior/bug has something to do with Object.preventExtension().
    // Fortunately this only impacts DEV builds.
    // Unfortunately it makes React unusably slow for some applications.
    // To work around this, initialize the fields below with doubles.
    //
    // Learn more about this here:
    // https://github.com/facebook/react/issues/14365
    // https://bugs.chromium.org/p/v8/issues/detail?id=8538
    this.actualDuration = Number.NaN; // 实际持续时间
    this.actualStartTime = Number.NaN; // 实际开始时间
    this.selfBaseDuration = Number.NaN; // 
    this.treeBaseDuration = Number.NaN;

    // It's okay to replace the initial doubles with smis after initialization.
    // This won't trigger the performance cliff mentioned above,
    // and it simplifies other profiler code (including DevTools).
    this.actualDuration = 0;
    this.actualStartTime = -1;
    this.selfBaseDuration = 0;
    this.treeBaseDuration = 0;
  }

  if (__DEV__) {
    // This isn't directly used but is handy for debugging internals:

    this._debugSource = null;
    this._debugOwner = null;
    this._debugNeedsRemount = false;
    this._debugHookTypes = null;
    if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {
      Object.preventExtensions(this);
    }
  }
}
```
这就是Fiber的结构。